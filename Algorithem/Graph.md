# Graph
    離散数学で扱われるグラフとは、頂点とその頂点同士が結ばれる辺で表されたもの。
    例えば、人との関係図や迷路、構成図、路線図など頂点と結ぶことで意味を表せるものである。

    用語には下記がある。
    - 辺重み付きグラフ
        頂点を接続する辺に意味を持たせるもの。例えば、重みとして数値をつけて関係度を調べたり、
        金額として料金計算したり、距離として最短距離を探したりといったことが示せる。
    - 有向グラフ
        頂点から頂点に移動できる方向を示し、一方向や両方向を示すことができる。
        ここに辺重みも組み合わせることで多くの情報を示すことができる。
    - 閉路
        視点と終点が繋がっており、終わりがない道があること。天使の輪っか。

# どんな種類？
## 幅優先探索
    頂点からゴールに対して段階的に全方位で調べていく方法で、データはFIFO(キュー)形式となる。
    例えば、下図でJがゴールだと、A-B, A-E, A-Hとまず調べ、次にB-C, E-F, H-Iと順番に調べる。最終的に最短の結果を見つけることができるが、進捗を保存する必要がある。

    A---B---C---D
      +-E---F---G
      +-H---I---J

## 深さ優先探索
    頂点から深さを優先して調べて、ゴールに辿り着けなかったら一段階戻ってまた深くまで探すということを繰り返す方法で、データはLIFO(スタック)形式となる。
    例えば、下図でJがゴールだと、A-B-C-Dと調べて、ダメならA-E-F-Gと調べていくようなこと。

    A---B---C---D
      +-E---F---G
      +-H---I---J

## ベルマン・フォード法 O(nm)
    頂点からゴールにたどり着くまでを計算していく方法。まず全ての頂点を無限とする。次にその頂点までに低く到達できるコストがあればその値を更新するという仕組みをもつ。この結果、より低いコストの道が見つかればコストを更新して記録し、高ければ更新しない。これを繰り返すことで最短経路を探すというもの。この方法は幅優先探索のようなもので、全ての道を計算していくので計算量は多くなる。

    計算量は頂点数をnで、変数をmとすると O(nm) となる。
    幅優先探索ということを考えると、各頂点のnを起点として辺の数を全て計算すれば、必ず成果にになるので、n*mとなり、計算量が O(nm)　となる。
    これは辺が負の場合でも対応できるので、辺に負があるなら適している一方で、正だけなら計算量が多いのでダイクストラ法のが良い。ちなみに負の場合で閉路がある場合は、延々とコストを下げれるので計算が終わらない。つまり最短と言える経路は存在しないという答えと考えられる。

## ダイクストラ法 O(m + n * logn)
    ベルマン・フォード法と比べると、深さ優先探索法のようなもので、自分の頂点から次の頂点に移動するのに最短のコストを計算して、その最短の頂点から次のコストを計算する。
    例えば、数でA-B, A-Dを比較して、A-Bが最短なら、B-C, B-Fをのコストを計算する。この時、A-B-C, A-B-F, A-Dと比較して一番小さいコストがA-Dなら、そこからD-Eと計算して、A-DーEを他と比較して計算を開始する。この一連を繰り返していくことでゴールにたどり着く手法。

    A---B---C
      | +---F
      +-D---E

    計算量は頂点数をnで、変数をmとすると O(m + n * logn) となる。
    この方法は辺が負の場合は対応できない（間違えた答えになる）が、計算量が少ないことから正だけならダイクストラ法のが良い。

## A*
    A*はスタートからゴールにたどり着く道順にコストの推定値を付与する方法。簡単に言えばゴールに近いほど少なめの重みをつけて、ゴールに遠いほど大きい重みをつける。計算にあたっては、本来のコスト＋重みを行い、コストが最小のものから探索を進めていく。結果、ゴールに遠い方を無駄に計算することが減るといった手法。
    しかし大前提として、探索前にコストをつける必要があるので、ゴールにこっちの方が近いという情報を知っていることが必要となる。
    例えばゲームとかでモンスターが近づいてくるアルゴリズムで利用される。
    主人公の周りから重みを1 ,2 ,3 ,4 と四方につけていけば、モンスターは無駄な方向に歩みを進める必要がないという考え方。すごい！