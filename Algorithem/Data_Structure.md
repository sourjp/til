# データ構造？  
    データの処理をする際に記憶領域としてメモリを利用する
    そのため、どのようにデータの構造を作るからでメモリを有効に利用することができる

# どんな種類？  
## リスト  
    メモリに格納したデータの末尾に「ポインタ」ををつけて、次のデータがどこにあるかを示すため「順次アクセス」という
    そのため、メモリではどこにおいてもたどり着けるので、ランダムに配置される
    検索に時間はかかる O(n) が、データの追加や削除はポインタの入れ替えで済むのは早い O(1) 
## 配列  
    添字を利用した構造で、メモリには順番に配置される
    添字によって直接データにアクセスすることができルため、これを「ランダムアクセス」という
    そのため、検索は早い O(1) が、データの追加や削除は添字位置の調整で時間がかかる O(n)
## スタック
    LIFO(Last In First Out)でデータを先に入れたものから積み上げて、最新から取り出す
    そのため最新の情報を取得するような仕組みに適しており、途中のデータを出すのには適していない
    これは (A(BC(D(EF)))) と「(」がデータの追加で、「)」で取り出しと見て、最新がEFとすぐわかる
## キュー
    FIFO(First In First Outでデータを入れた順番から取り出す手法で感覚的にわかりやすい
    これは順番に取り出すことに適しており、途中のデータを出すのには適していない
## ハッシュテーブル
    Key: Value型のデータを格納する手法
    KeyのHashを計算*して、それに従ってKeyとValueを格納する。
    これによってKeyの参照依頼が来たときに、直接アクセスすることができる。
    *一般的？にはkeyの値をHash値として、格納するデータ領域をNとして%を出して位置を決める。
     もし重複した場合は、リストのようにポインタで接続する。
     そのためデータの領域によってはリストばかりになったり、無駄に余ることもあるので注意が必要。
## ヒープ
    木構造で、最大二つのデータが繋がっていく。
    このとき、親が子よりも数字が大きいことをルールになるように統一する。
    データの追加や削除があった時は、順に比較して埋め込む。
## 二分探索木
    木構造で、最大二つのデータが繋がっていく。
    このとき、左側が自分より低い値、右側が自分より高い値になるように統一することで、最小値は左側で最大値は右側に行けばたどり着ける構造になる。
    データの追加や削除があった時は、順に比較して埋め込む。

